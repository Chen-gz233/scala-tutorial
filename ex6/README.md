# 特质

## 什么是特质
因为Scala没有多重继承，为了提高代码复用率，故而创造了新的编程概念——特质。

特质是用关键字“trait”为开头来定义的，它与单例对象很像，两者都**不能有入参**。但是，单例对象天生就是**具体**的，特质天生就是**抽象**的，不过**不需要**用“abstract”来说明。所以，特质可以包含抽象成员，而单例对象却不行。

另外，两者**都不能**用new来实例化，因为特质是抽象的，而单例对象已经是具体的对象。类、单例对象和特质三者一样，内部可以包含字段和方法，甚至包含其他类、单例对象、特质的定义。

特质可以被其它类、单例对象和特质“**混入**”。这里使用术语“**混入**”而不是“**继承**”，是因为**特质在超类方法调用上采用线性化机制**，与多重继承有很大的区别。**其它方面**，“混入”和“继承”其实**是一样的**。例如，某个类混入一个特质后，就**包含了特质的所有公有成员**，而且也**可以用“override”来重写**特质的成员。

Scala只允许继承自一个类，但是对特质的混入数量却没有限制，故而可用于**替代多重继承**语法。要混入一个特质，**可以使用关键字“extends”**。但如果“extends”已经被占用了，比如已经拿去继承一个类或混入一个特质，那么后续则通过关键字“**with**”来混入其他特质。


## 特质的层次 

特质也可以继承自其他类，或混入任意个特质，这样该特质就是关键字“**extends**”引入的那个类/特质的子特质。
## 特质的线性化叠加计算
多重继承一个很明显的问题是，当子类调用超类的方法时，若多个超类都有该方法的不同实现，那么需要附加额外的语法来确定具体调用哪个版本。Scala的特质则是采取一种线性化的规则来调用特质中的方法，这与大多数语言不一样。在特质里，“super”调用是动态绑定的。也就是说，按特质本身的定义，无法确定super调用的具体行为；直到特质混入某个类或别的特质，有了具体的超类方法，才能确定super的行为。这是实现线性化的基础。








